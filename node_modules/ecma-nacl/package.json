{
  "name": "ecma-nacl",
  "version": "1.4.0",
  "description": "JavaScript (ECMAScript) version of NaCl Cryptographic library",
  "main": "./lib/ecma-nacl.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/3nsoft/ecma-nacl.git"
  },
  "engines": {
    "node": "*"
  },
  "devDependencies": {
    "browserify": ">=2.34.3",
    "js-nacl": "0.5.0"
  },
  "keywords": [
    "encryption",
    "high-level",
    "crypto",
    "nacl"
  ],
  "contributors": [
    {
      "name": "Mikalai Birukou",
      "email": "mikalai@birukou.net"
    }
  ],
  "license": {
    "type": "MPLv2.0",
    "url": "http://mozilla.org/MPL/2.0/"
  },
  "readmeFilename": "README.md",
  "readme": "# ecma-nacl: Pure JavaScript (ECMAScript) version of NaCl cryptographic library.\n\n[NaCl](http://nacl.cr.yp.to/) is a great crypto library that is not placing a burden of crypto-math choices onto developers, providing only solid high-level functionality (box - for public-key, and secret_box - for secret key  authenticated encryption), in a let's [stop blaming users](http://cr.yp.to/talks/2012.08.08/slides.pdf) of cryptographic library (e.g. end product developers, or us) manner.\nTake a look at details of NaCl's design  \"[The security impact of a new cryptographic\nlibrary](http://cr.yp.to/highspeed/coolnacl-20120725.pdf)\".\n\necma-nacl is a re-write of most important NaCl's functionality, which is ready for production, box and secret_box. Signing code still has XXX comments, indicating that the warning in [signing in NaCl](http://nacl.cr.yp.to/sign.html) should be taken seriously.\n\nRewrite is based on the copy of NaCl, included in this repository.\nTests are written to correspond those in C code, to make sure that output of this library is the same as that of C's version.\nBesides this, we added comparison runs between ecma-nacl, and js-nacl, which is an [Emscripten](https://github.com/kripken/emscripten)-compilation of C library.\nThese comparison runs can be done in both node and browsers.\n\nAs of version 0.5, js-nacl is properly compiled into [asm.js](http://asmjs.org/spec/latest/) code, recognized by Firefox.\nProper asm.js does run two times faster than pure js.\nSo, we have a tradeoff here: with js-nacl one gets speed, which realistically matters on client side when encrypting 100s MBs of data, and with ecma-nacl one gets smaller library size and better auditability.\nAsm.js might still be a moving target, while ecma-nacl is exploiting only those JS features that has already been widely implemented.\nAt the same time, js-nacl keeps C-ish api, while ecma-nacl is providing JS-ish api, adding convenient packaging features.\nIn fact, we are confident, that things like XSP file format, introduced in ecma-nacl api, shall spread beyond JS implementations of NaCl.\n\n## NPM Package\n\nThis library is [registered on\nnpmjs.org](https://npmjs.org/package/ecma-nacl). To install it:\n\n    npm install ecma-nacl\n\n## Browser Package\n\nmake-browserified.js will let you make a browserified module. So, make sure that you have [browserify module](http://browserify.org/) to run the script. You may also modify it to suite your particular needs.\n\n## API for secret-key authenticated encryption\n\nAdd module into code as\n```javascript\nvar nacl = require('ecma-nacl');\n```\n\n[Secret-key authenticated](http://nacl.cr.yp.to/secretbox.html) encryption is provided by secret_box, which implements XSalsa20+Poly1305, and nothing else.\n\nWhen encrypting, or packing, NaCl does following things. First, it encrypts plain text bytes using XSalas20 algorithm. Secondly, it creates 16 bytes of authentication Poly1305 code, and places these infront of the cipher. Thus, regular byte layout is 16 bytes of Poly1305 code, followed by cipher with actual message, having exactly the same length as plain text message.\n\nDecrypting, or opening goes through these steps in reverse. First, Poly1305 code is read and is compared with code, generated by reading cipher. When these do not match, it means either that key+nonce pair is incorrect, or that cipher with message has been damaged/changed. Our code will throw an exception in such a case. Secondly, when verification is successful, XSalsa20 will do decryption, producing message bytes.\n```javascript\n// all incoming and outgoing things are Uint8Array's;\n// to encrypt, or pack plain text bytes into cipher bytes, use\nvar cipher_bytes = nacl.secret_box.pack(plain_bytes, nonce, key);\n\n// decryption, or opening is done by\nvar result_bytes = nacl.secret_box.open(cipher_bytes, nonce, key);\n```\n\nAbove pack method will produce an Uint8Array with cipher, offset by 16 zero bytes in the underlying buffer. Deciphered bytes, on the other hand, are offset by 32 zero bytes. This should always be kept in mind, when transferring raw buffers to/from web-workers. In all other places, this padding is never noticed, thanks to [typed array api](https://developer.mozilla.org/en-US/docs/Web/API/Uint8Array).\n\nKey is 32 bytes long. Nonce is 24 bytes. Nonce means number-used-once, i.e. it should be unique for every segment encrypted by the same key.\n\nSometimes, when storing things, it is convenient to pack cipher together with nonce (WN) into the same array.\n\n    +-------+ +------+ +---------------+\n    | nonce | | poly | |  data cipher  |\n    +-------+ +------+ +---------------+\n    | <----       WN format      ----> |\n\nFor this, secret_box has formatWN object, which is used analogously:\n```javascript\n// encrypting, and placing nonce as first 24 bytes infront NaCl's byte output layout\nvar cipher_bytes = nacl.secret_box.formatWN.pack(plain_bytes, nonce, key);\n\n// decryption, or opening is done by\nvar result_bytes = nacl.secret_box.formatWN.open(cipher_bytes, key);\n\n// extraction of nonce from cipher can be done as follows\nvar extracted_nonce = nacl.secret_box.formatWN.copyNonceFrom(cipher_bytes);\n```\n\nCipher array here has no offset in the buffer, but decrypted array does have the same 32 zero bytes offset, as mentioned above.\n\nIt is important to always use different nonce, when encrypting something new with the same key. A function is provided, to advance nonce. The 24 bytes are taken as three 32-bit integers, and are advanced by 1 (oddly) or by 2 (evenly). So, when encrypting many segments of a huge file, advance nonce oddly every time. When key is shared, and is used for communication between two parties, one party's initial nonce may be oddly advanced initial nonce, received from the second party, and all other respective nonces are advanced evenly on both sides of communication. This way, unique nonces are used for every message send.\n```javascript\n// nonce changed in place oddly\nnacl.advanceNonceOddly(nonce);\n\n// nonce changed in place evenly\nnacl.advanceNonceEvenly(nonce);\n```\n\nIt is common, that certain code needs to be given encryption/decryption functionality, but according to [principle of least authority](https://en.wikipedia.org/wiki/Principle_of_least_privilege) such code does not necessarily need to know secret key, with which encryption is done. So, there is an encryptor for opening and packing, with inbuilt even advance of the nonce, on every new cipher that is generated. It is made to produce and read ciphers with-nonce format.\n```javascript\nvar encryptor = nacl.secret_box.formatWN.makeEncryptor(key, nextNonce);\n\n// packing bytes is done with\nvar cipher_bytes = encryptor.pack(plain_bytes);\n\n// opening is done with\nvar result_bytes = encryptor.open(cipher_bytes);\n\n// when encryptor is no longer needed, key should be properly wiped from memory\nencryptor.destroy();\n```\n\n## API for public-key authenticated encryption\n\n[Public-key authenticated](http://nacl.cr.yp.to/box.html) encryption is provided by box, which implements Curve25519+XSalsa20+Poly1305, and nothing else. Given pairs of secret-public keys, corresponding shared, in Diffieâ€“Hellman sense, key is calculated (Curve25519) and is used for data encryption with secret_box (XSalsa20+Poly1305).\n\nGiven any random secret key, we can generate corresponding public key:\n```javascript\nvar public_key = nacl.box.generate_pubkey(secret_key);\n```\n\nSecret key may come from browser's crypto.getRandomValues(array), or be derived from passphrase with [js-scrypt](https://github.com/tonyg/js-scrypt), which is an emscripten-compiled [original C library](http://www.tarsnap.com/scrypt.html).\n\nThere are two ways to use box. The first way is to always do two things, calculation of DH-shared key and subsequent packing/opening, in one step.\n```javascript\n// Alice encrypts message for Bob\nvar cipher_bytes = nacl.box.pack(msg_bytes, nonce, bob_pkey, alice_skey);\n\n// Bob opens the message\nvar msg_bytes = nacl.box.open(cipher_bytes, nonce, alice_pkey, bob_skey);\n```\n\nThe second way is to calculate DH-shared key once and use it for packing/opening multiple messages, with box.stream.pack and box.stream.open, which are just nicknames of described above secret_box.pack and secret_box.open.\n```javascript\n// Alice calculates DH-shared key\nvar dhshared_key = nacl.box.calc_dhshared_key(bob_pkey, alice_skey);\n// Alice encrypts message for Bob\nvar cipher_bytes = nacl.box.stream.pack(msg_bytes, nonce, dhshared_key);\n\n// Bob calculates DH-shared key\nvar dhshared_key = nacl.box.calc_dhshared_key(alice_pkey, bob_skey);\n// Bob opens the message\nvar msg_bytes = nacl.box.stream.open(cipher_bytes, nonce, dhshared_key);\n```\n\nOr, we may use box encryptors that do first step of DH-shared key calculation only at creation.\n\nAlice's side:\n```javascript\n// generate nonce, browser example\nvar nonce = new Uint8Array(24);\ncrypto.getRandomValues(nonce);\n\n// make encryptor to produce with-nonce format\nvar encryptor = nacl.box.formatWN.makeEncryptor(bob_pkey, alice_skey, nonce);\n\n// pack messages to Bob\nvar cipher_to_send = encryptor.pack(msg_bytes);\n\n// open mesages from Bob\nvar msg_from_bob = encryptor.open(received_cipher);\n    \n// when encryptor is no longer needed, key should be properly wiped from memory\nencryptor.destroy();\n```\n\nBob's side:\n```javascript\n// get nonce from Alice's first message, advance it oddly, and\n// use for encryptor, as encryptors on both sides advance nonces evenly\nvar nonce = nacl.box.formatWN.copyNonceFrom(cipher1_from_alice);\nnacl.advanceNonceOddly(nonce);\n\n// make encryptor to produce with-nonce format\nvar encryptor = nacl.box.formatWN.makeEncryptor(alice_pkey, bob_skey, nonce);\n\n// pack messages to Alice\nvar cipher_to_send = encryptor.pack(msg_bytes);\n\n// open mesages from Alice\nvar msg_from_alice = encryptor.open(received_cipher);\n    \n// when encryptor is no longer needed, key should be properly wiped from memory\nencryptor.destroy();\n```\n\n## Random number generation\n\nNaCl does not do it. The randombytes in the original code is a unix shim with the following rational, given in the comment, quote: \"it's really stupid that there isn't a syscall for this\".\n\nSo, you should obtain cryptographically strong random bytes yourself. In node, there is crypto. There is crypto in browser. IE6? IE6 must die! Stop supporting insecure crap! Respect your users, and tell them truth, that they need modern secure browser(s).\n\n## Signing\n\nIt is still not settled into production code in NaCl. Period. When it is ready, we will be able to serve it.\n\n[DNSCurve](http://dnscurve.org/) is questioning whether common places of signing be better served with public-key encryption.\n\n## XSP file format\n\nEach NaCl's cipher must be read completely, before any plain text output.\nSuch requirement makes reading big files awkward.\nThus, the simplest solution is to pack NaCl's binary ciphers into\nself-contained small segments, each encrypted with a different nonce.\nSuch segment-based format is also useful in a streaming situation, when one\nend starts to send a file, without knowing when EOF comes.\n\nWe call this format XSP, to stand for XSalsa+Poly, to indicate that file layout\nis specifically tailored for storing NaCl's secret box's ciphers.\n\nEach segment contains a header.\nThe first segment contains a file header, followed by a common segment header.\n\nFile header layout:\n\n    +-----+  +-------------------+ +--------------+\n    | xsp |  | file key envelope | | max seg size |\n    +-----+  +-------------------+ +--------------+\n\nFirst three bytes is a constant ASCII encoded string 'xsp'.\nThis takes up first 3 bytes.\n\n\"File key envelope\" is an encrypted, and packed with-nonce (WN format), key,\nused to encrypt every segment of a given file.\nLength of this envelope calculated as follows: key is 32 bytes, add 16 Poly\nbytes, and 24 nonce.\nThis gives 72 bytes for file key envelope.\n\n\"Max seg size\" is 4 bytes with a maximum, or common segment length, written\nin little endian way.\nTotal length of any segment in this file should never exceed given value. \n\nThus, file header, has a predictable length of 79 bytes.\n\nSegment layout:\n\n    | <-- segment header  --> |\n    +-------------------------+ +---------------+\n    | seg size | nonce | poly | |  data cipher  |\n    +-------------------------+ +---------------+\n               | <----      WN format     ----> |\n\nSegment starts with 4 bytes, containing total length of this segment, written\nin little endian way.\nNext 40 bytes contain nonce and poly bytes.\nThese first 44 bytes we call a segment header.\n\nNotice that nonce and poly in the header are layed out so, that together with\nthe following data cipher, they constitute WN pack format.\n\nFirst segment layout:\n\n    +-------------+ +----------------+ +---------------+\n    | file header | | segment header | |  data cipher  |\n    +-------------+ +----------------+ +---------------+\n\nData cipher are the crypto stream bytes, into which data was xor-ed.\nTherefore, data cipher's length is exactly the same as encoded data's length.\n\n## API for packing/opening XSP segments \n\nThere is a sub-module, with XSP-related functionality:\n```javascript\nvar xsp = nacl.fileXSP;\n```\n\nEach xsp object has two encrypted parts that use different keys.\nOne part is the content, encrypted with file key.\nAnother part is an encrypted file key package, which is encrypted with some\nmaster key.\nThus, to instantiate encryptor, we need a file key, and a function that will encrypt\nit to a master key. Notice, that we can provide master key itself, but, a principle\nof least priviledge dictates that we should provide only required master key's\nencrypting capability, and nothing else.\n```javascript\n// we should get or generate a file key\nvar fileKey = foo();\n// given master key encryptor, we can take its pack function\nvar fileKeyPackFunc = masterKeyEnc.pack;\nvar fileKeyOpenFunc = masterKeyEnc.open;\n```\n\nThere are two situations, in which xsp encryptor can be initialized.\nFirst situation is when there is no existing xsp file:\n```javascript\nvar enc = xsp.makeNewFileEncryptor(maxSegSize, fileKey, fileKeyPackFunc);\n```\n\nSecond situation is when file exists:\n```javascript\nvar enc = xsp.makeExistingFileEncryptor(firstSegHeader, fileKeyOpenFunc);\n```\n\nEncryptor can pack Uint8Array data into segments:\n```javascript\nvar segments = []\n, dataOffset = 0;\n    \n// packing first segment uses special method\nvar encRes = enc.packFirstSegment(data, nonce);\n    \n// result object has created segment, and a number of packed data bytes\nsegments.push( encRes.seg );\ndataOffset += encRes.dataLen;\n    \n// nonce must be changed for use in a different segment\nnacl.advanceNonceOddly(nonce);\n\nwhile(dataOffset < data.length) {\n        \n    // packing other segments\n    encRes = enc.packSegment(data, nonce);\n        \n    segments.push( encRes.seg );\n    dataOffset += encRes.dataLen;\n    nacl.advanceNonceOddly(nonce);\n}\n```\n\nEncryptor can open segments (notice how incoming arrays must be alligned\nwith segments' starting point), given complete xsp file as Uint8Array:\n```javascript\nvar fileOffset = 0\n, dataParts = []\n, decRes;\n    \nwhile(fileOffset < xspFile.length) {\n        \n    decRes = enc.openSegment( xspFile.subarray(fileOffset) );\n        \n    // result object has opened data, and segment's size, read from file\n    dataParts.push( decRes.data );\n    fileOffset += decRes.segLen\n}\n```\n\nEncryptors should be properly disposed after use:\n```javascript\nenc.destroy();\n```\n\n\n## License\n\nThis code is provided here under [Mozilla Public License Version 2.0](https://www.mozilla.org/MPL/2.0/).\n\nNaCl C library is public domain code by Daniel J. Bernstein and others crypto gods and semi-gods. We thank thy wisdom of giving us developer-friendly library.\n",
  "bugs": {
    "url": "https://github.com/3nsoft/ecma-nacl/issues"
  },
  "_id": "ecma-nacl@1.4.0",
  "_from": "ecma-nacl@"
}
